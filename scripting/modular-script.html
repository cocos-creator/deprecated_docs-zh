<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
    <title>模块化脚本</title>
    <link type="text/css" rel="stylesheet" href="../assets/css/github-markdown.css">
    <link type="text/css" rel="stylesheet" href="../assets/css/pilcrow.css">
    <link type="text/css" rel="stylesheet" href="../assets/css/hljs-github.min.css"/>
    <link type="text/css" rel="stylesheet" href="../assets/css/style.css"/>
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
  </head>
  <body>
  <div class="full-wrap">
    <div class="sidebar markdown-body">
      <div class="inner">
        <div class="logo">
          <a href="../index.html"><img src="../assets/img/logo.png"></a>
        </div>
        <ul class="nav nav-list">
          <li class="sidebar-header-1 "><h3><a href="../getting-started/index.html">Cocos Creator 入门</a></h3></li>
          <li class=" sidebar-header-3"><a href="../getting-started/introduction.html">关于 Cocos Creator</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/install.html">安装和启动</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/dashboard.html">使用 Dashboard</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/hello-world.html">Hello World!</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/quick-start.html">快速上手: 制作第一个游戏</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/cocos2d-x-guide.html">Cocos2d-x 用户上手指南</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/unity-guide.html">Unity 用户上手指南</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/project-structure.html">项目结构</a></li>
          <li class=" sidebar-header-3"><a href="../getting-started/support.html">获取帮助和支持</a></li>
          <li class="sidebar-header-1 "><h3><a href="../basics/index.html">编辑器基础</a></h3></li>
          <li class=" sidebar-header-3"><a href="../basics/editor-overview.html">编辑器界面介绍</a></li>
          <li class=" sidebar-header-4"><a href="../basics/editor-panels/assets.html">资源管理器</a></li>
          <li class=" sidebar-header-4"><a href="../basics/editor-panels/scene.html">场景编辑器</a></li>
          <li class=" sidebar-header-4"><a href="../basics/editor-panels/hierarchy.html">层级管理器</a></li>
          <li class=" sidebar-header-4"><a href="../basics/editor-panels/inspector.html">属性检查器</a></li>
          <li class=" sidebar-header-4"><a href="../basics/editor-panels/console.html">控制台</a></li>
          <li class=" sidebar-header-3"><a href="../basics/toolbar.html">工具栏</a></li>
          <li class=" sidebar-header-3"><a href="../basics/layout.html">编辑器布局</a></li>
          <li class="sidebar-header-1 "><h3><a href="../asset-workflow/index.html">资源工作流程</a></h3></li>
          <li class=" sidebar-header-3"><a href="../asset-workflow/scene-managing.html">创建和管理场景</a></li>
          <li class=" sidebar-header-3"><a href="../asset-workflow/sprite.html">图像资源（Texture）</a></li>
          <li class=" sidebar-header-3"><a href="../asset-workflow/atlas.html">图集资源（Atlas）</a></li>
          <li class=" sidebar-header-3"><a href="../asset-workflow/font.html">字体资源</a></li>
          <li class=" sidebar-header-3"><a href="../asset-workflow/particle.html">粒子资源</a></li>
          <li class=" sidebar-header-3"><a href="../asset-workflow/audio-asset.html">声音资源（AudioClip）</a></li>
          <li class=" sidebar-header-3"><a href="../asset-workflow/prefab.html">预制资源（Prefab）</a></li>
          <li class="sidebar-header-1 "><h3><a href="../content-workflow/index.html">内容创作工作流程</a></h3></li>
          <li class=" sidebar-header-3"><a href="../content-workflow/node-component.html">节点和组件</a></li>
          <li class=" sidebar-header-3"><a href="../content-workflow/transform.html">坐标系和变换</a></li>
          <li class=" sidebar-header-3"><a href="../content-workflow/node-tree.html">管理节点层级和显示顺序</a></li>
          <li class=" sidebar-header-3"><a href="../content-workflow/scene-editing.html">使用场景编辑器搭建场景图像</a></li>
          <li class="sidebar-header-1 "><h3><a href="../ui/index.html">UI 系统</a></h3></li>
          <li class=" sidebar-header-3"><a href="../ui/sliced-sprite.html">使用 Sliced Sprite 制作 UI 图像</a></li>
          <li class=" sidebar-header-3"><a href="../ui/multi-resolution.html">多分辨率适配方案</a></li>
          <li class=" sidebar-header-3"><a href="../ui/widget-align.html">对齐策略</a></li>
          <li class=" sidebar-header-3"><a href="../ui/label-layout.html">文字排版</a></li>
          <li class=" sidebar-header-3"><a href="../ui/ui-components.html">常用 UI 控件</a></li>
          <li class=" sidebar-header-3"><a href="../ui/auto-layout.html">自动布局容器</a></li>
          <li class=" sidebar-header-3"><a href="../ui/list-with-data.html">制作动态生成内容的列表</a></li>
          <li class="sidebar-header-1 "><h3><a href="../animation/index.html">动画系统</a></h3></li>
          <li class=" sidebar-header-3"><a href="../animation/animation.html">关于 Animation</a></li>
          <li class=" sidebar-header-3"><a href="../animation/animation-clip.html">创建 Animation 组件和动画剪辑</a></li>
          <li class=" sidebar-header-3"><a href="../animation/animation-curve.html">编辑动画曲线</a></li>
          <li class=" sidebar-header-3"><a href="../animation/sprite-animation.html">编辑序列帧动画</a></li>
          <li class=" sidebar-header-3"><a href="../animation/time-curve.html">编辑时间曲线</a></li>
          <li class=" sidebar-header-3"><a href="../animation/animation-event.html">添加动画事件</a></li>
          <li class=" sidebar-header-3"><a href="../animation/scripting-animation.html">使用脚本控制动画</a></li>
          <li class="sidebar-header-1 "><h3><a href="../components/index.html">组件参考</a></h3></li>
          <li class=" sidebar-header-3"><a href="../components/sprite.html">Sprite 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/label.html">Label 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/animation.html">Animation 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/canvas.html">Canvas 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/widget.html">Widget 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/progress.html">ProgressBar 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/button.html">Button 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/mask.html">Mask 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/scrollview.html">ScrollView 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/scrollbar.html">ScrollBar 组件参考</a></li>
          <li class=" sidebar-header-3"><a href="../components/layout.html">Layout 组件参考</a></li>
          <li class="sidebar-header-1 "><h3><a href="index.html">脚本开发工作流程</a></h3></li>
          <li class=" sidebar-header-3"><a href="use-component.html">创建和使用组件脚本</a></li>
          <li class=" sidebar-header-3"><a href="properties.html">声明属性</a></li>
          <li class=" sidebar-header-3"><a href="access-node-component.html">访问节点和其他组件</a></li>
          <li class=" sidebar-header-3"><a href="life-cycle-callbacks.html">生命周期回调</a></li>
          <li class=" sidebar-header-3"><a href="create-destroy.html">创建和销毁节点</a></li>
          <li class=" sidebar-header-3"><a href="events.html">发射和监听事件</a></li>
          <li class=" sidebar-header-3"><a href="internal-events.html">系统内置事件</a></li>
          <li class=" sidebar-header-3"><a href="actions.html">使用动作系统</a></li>
          <li class=" sidebar-header-3"><a href="action-list.html">动作列表</a></li>
          <li class=" sidebar-header-3"><a href="scheduler.html">使用计时器</a></li>
          <li class=" sidebar-header-3"><a href="execution-order.html">脚本执行顺序</a></li>
          <li class=" sidebar-header-3"><a href="pooling.html">使用对象池</a></li>
          <li class=" sidebar-header-3"><a href="load-assets.html">获取资源</a></li>
          <li class="active sidebar-header-3"><a href="modular-script.html">模块化脚本</a></li>
          <li class=" sidebar-header-3"><a href="web-debug-scripts.html">在浏览器中调试脚本</a></li>
          <li class=" sidebar-header-3"><a href="javascript-primer.html">JavaScript 快速入门</a></li>
          <li class=" sidebar-header-4"><a href="reference/attributes.html">属性参数参考</a></li>
          <li class="sidebar-header-1 "><h3><a href="../publish/index.html">跨平台发布游戏</a></h3></li>
          <li class=" sidebar-header-3"><a href="../publish/publish-web.html">发布到 Web 平台</a></li>
          <li class=" sidebar-header-3"><a href="../publish/cocos-framework.html">安装配置 Cocos Framework</a></li>
          <li class=" sidebar-header-3"><a href="../publish/publish-native.html">打包发布原生平台</a></li>
        </ul>
      </div>
    </div>
    <div class="main">
      <article class="markdown-body"><h1 id="-">模块化脚本</h1>
<p>Cocos Creator 允许你将代码拆分成多个脚本文件，并且让它们相互调用。要实现这点，你需要了解如何在 Cocos Creator 中定义和使用模块，这个步骤简称为<strong>模块化</strong>。</p>
<p>如果你还不确定模块化究竟能做什么，模块化相当于：</p>
<ul class="list">
<li>C/C++ 中的 <code>include</code></li>
<li>C# 中的 <code>using</code></li>
<li>Java 和 Python 中的 <code>import</code></li>
<li>HTML 中的 <code>&lt;link&gt;</code></li>
</ul>
<p>模块化使你可以在 Cocos Creator 中引用其它脚本文件：  </p>
<ul class="list">
<li>访问其它文件导出的参数</li>
<li>调用其它文件导出的方法</li>
<li>使用其它文件导出的类型</li>
<li>使用或继承其它 Component</li>
</ul>
<p>Cocos Creator 中的 JavaScript 使用和 Node.js 几乎相同的 CommonJS 标准来实现模块化，简单来说：</p>
<ul class="list">
<li>每一个单独的脚本文件就构成一个模块</li>
<li>每个模块都是一个单独的作用域</li>
<li>以<strong>同步</strong>的 <code>require</code> 方法来引用其它模块</li>
<li>设置 <code>module.exports</code> 为导出的变量</li>
</ul>
<p>如果你还不太明白，没关系，下面会详细讲解。</p>
<blockquote>
<p>在本文中，“模块”和“脚本”这两个术语是等价的。所有“备注”都属于进阶内容，一开始不需要了解。<br>不论模块如何定义，所有用户代码最终会由 Cocos Creator 编译为原生的 JavaScript，可直接在浏览器中运行。</p>
</blockquote>
<h2 id="--1">引用模块</h2>
<h3 id="require">require</h3>
<p>除了 Cocos Creator 提供的接口，所有用户定义的模块都需要调用 <code>require</code> 来访问。例如我们有一个组件定义在 <code>Rotate.js</code>：</p>
<pre class="hljs"><code><span class="hljs-comment">// Rotate.js</span>

cc.Class({
   extends: cc.Component,
   <span class="hljs-comment">// ...</span>
});</code></pre><p>现在要在别的脚本里访问它，可以：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> Rotate = <span class="hljs-built_in">require</span>(<span class="hljs-string">"Rotate"</span>);</code></pre><p><code>require</code> 返回的就是被模块导出的对象，通常我们都会将结果立即存到一个变量（<code>var Rotate</code>）。传入 <code>require</code> 的字符串就是模块的<strong>文件名</strong>，这个名字不包含路径也不包含后缀，而且大小写敏感。</p>
<h3 id="require-">require 完整范例</h3>
<p>接着我们就可以使用 Rotate 派生一个子类，新建一个脚本 <code>SinRotate.js</code>：</p>
<pre class="hljs"><code><span class="hljs-comment">// SinRotate.js</span>

<span class="hljs-keyword">var</span> Rotate = <span class="hljs-built_in">require</span>(<span class="hljs-string">"Rotate"</span>);

<span class="hljs-keyword">var</span> SinRotate = cc.Class({
    extends: Rotate,
    update: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dt</span>) </span>{
        <span class="hljs-keyword">this</span>.rotation += <span class="hljs-keyword">this</span>.speed * <span class="hljs-built_in">Math</span>.sin(dt);
    }
});</code></pre><p>这里我们定义了一个新的组件叫 SinRotate，它继承自 Rotate，并对 <code>update</code> 方法进行了重写。</p>
<blockquote>
<p>同样的这个组件也可以被其它脚本接着访问，只要用 <code>require(&quot;SinRotate&quot;)</code>。</p>
</blockquote>
<p>备注：</p>
<ul class="list">
<li><code>require</code> 可以在脚本的任何地方任意时刻进行调用。</li>
<li>游戏开始时会自动 require 所有脚本，这时每个模块内部定义的代码就会被执行一次，所以之后无论又被 require 几次，返回的始终是同一份实例。</li>
<li>调试时，可以随时在 <strong>Developer Tools</strong> 的 <strong>Console</strong> 中 require 项目里的任意模块。</li>
</ul>
<h2 id="--2">定义模块</h2>
<h3 id="--3">定义组件</h3>
<p>每一个单独的脚本文件就是一个模块，例如前面新建的脚本 <code>Rotate.js</code>：</p>
<pre class="hljs"><code><span class="hljs-comment">// Rotate.js</span>

<span class="hljs-keyword">var</span> Rotate = cc.Class({
    extends: cc.Component,
    properties: {
        speed: <span class="hljs-number">1</span>
    },
    update: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.transform.rotation += <span class="hljs-keyword">this</span>.speed;
    }
});</code></pre><p>当你在脚本中声明了一个组件，Cocos Creator 会默认把它导出，其它脚本直接 require 这个模块就能使用这个组件。</p>
<h3 id="-javascript-">定义普通 JavaScript 模块</h3>
<p>模块里不单单能定义组件，实际上你可以导出任意 JavaScript 对象。假设有个脚本 <code>config.js</code></p>
<pre class="hljs"><code><span class="hljs-comment">// config.js</span>

<span class="hljs-keyword">var</span> config = {
    moveSpeed: <span class="hljs-number">10</span>,
    version: <span class="hljs-string">"0.15"</span>,
    showTutorial: <span class="hljs-literal">true</span>,

    load: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
};
config.load();</code></pre><p>现在如果我们要在其它脚本中访问 <code>config</code> 对象：</p>
<pre class="hljs"><code><span class="hljs-comment">// player.js</span>

<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">"config"</span>);
cc.log(<span class="hljs-string">"speed is"</span>, config.moveSpeed);</code></pre><p>结果会有报错：&quot;TypeError: Cannot read property &#39;moveSpeed&#39; of null&quot;，这是因为 <code>config</code> 没有设置为导出对象。我们还需要在 <code>config.js</code> 的最后把 <code>module.exports</code> 设置成 <code>config</code>：</p>
<pre class="hljs"><code><span class="hljs-built_in">module</span>.exports = config;</code></pre><p>这样做的原因是只要有其它脚本 require 它，获得的实际上就是这里的 <code>module.exports</code> 对象。</p>
<blockquote>
<p>那为什么定义 Component 时可以不用设置 <code>exports</code> ？
  因为 Component 是 Cocos Creator 中的特殊类型，如果一个脚本定义了 Component 却没有声明 <code>exports</code>，Cocos Creator 会自动将 <code>exports</code> 设置为 Component。</p>
</blockquote>
<p>完整代码如下：</p>
<pre class="hljs"><code><span class="hljs-comment">// config.js</span>

<span class="hljs-keyword">var</span> config = {
    moveSpeed: <span class="hljs-number">10</span>,
    version: <span class="hljs-string">"0.15"</span>,
    showTutorial: <span class="hljs-literal">true</span>,

    load: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
};
config.load();

<span class="hljs-built_in">module</span>.exports = config;</code></pre><pre class="hljs"><code><span class="hljs-comment">// player.js</span>

<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">"config"</span>);
cc.log(<span class="hljs-string">"speed is"</span>, config.moveSpeed);</code></pre><p>这样便能正确输出：&quot;speed is 10&quot;。</p>
<h2 id="--4">更多示例</h2>
<h3 id="--5">导出变量</h3>
<ul class="list">
<li><code>module.exports</code> 默认是一个空对象（<code>{}</code>），可以直接往里面增加新的字段。</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// foobar.js:</span>

<span class="hljs-built_in">module</span>.exports.foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    cc.log(<span class="hljs-string">"foo"</span>);
};
<span class="hljs-built_in">module</span>.exports.bar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    cc.log(<span class="hljs-string">"bar"</span>);
};</code></pre><pre class="hljs"><code><span class="hljs-comment">// test.js:</span>

<span class="hljs-keyword">var</span> foobar = <span class="hljs-built_in">require</span>(<span class="hljs-string">"foobar"</span>);
foobar.foo();    <span class="hljs-comment">// "foo"</span>
foobar.bar();    <span class="hljs-comment">// "bar"</span></code></pre><ul class="list">
<li><code>module.exports</code> 的值可以是任意 JavaScript 类型。</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// foobar.js:</span>

<span class="hljs-built_in">module</span>.exports = {
    FOO: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">"foo"</span>;
    },
    bar: <span class="hljs-string">"bar"</span>
};</code></pre><pre class="hljs"><code><span class="hljs-comment">// test.js:</span>

<span class="hljs-keyword">var</span> foobar = <span class="hljs-built_in">require</span>(<span class="hljs-string">"foobar"</span>);
<span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> foobar.FOO();
cc.log(foo.type);      <span class="hljs-comment">// "foo"</span>
cc.log(foobar.bar);    <span class="hljs-comment">// "bar"</span></code></pre><h3 id="--6">封装私有变量</h3>
<p>每个脚本都是一个单独的作用域，在脚本内使用 <code>var</code> 定义的局部变量，将无法被模块外部访问。我们可以很轻松的封装模块内的私有变量：</p>
<pre class="hljs"><code><span class="hljs-comment">// foobar.js:</span>

<span class="hljs-keyword">var</span> dirty = <span class="hljs-literal">false</span>;
<span class="hljs-built_in">module</span>.exports = {
    setDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        dirty = <span class="hljs-literal">true</span>;
    },
    isDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> dirty;
    },
};</code></pre><pre class="hljs"><code><span class="hljs-comment">// test1.js:</span>

<span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">"foobar"</span>);
cc.log(<span class="hljs-keyword">typeof</span> foo.dirty);        <span class="hljs-comment">// "undefined"</span>
foo.setDirty();</code></pre><pre class="hljs"><code><span class="hljs-comment">// test2.js:</span>

<span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">"foobar"</span>);
cc.log(foo.isDirty());           <span class="hljs-comment">// true</span></code></pre><p><strong>警告：定义变量前记得要在前面加上 <code>var</code></strong>，否则将会变成全局变量！</p>
<pre class="hljs"><code><span class="hljs-comment">// foobar.js:</span>

dirty = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 不推荐将 dirty 设成全局变量！前面应该加上 var!</span>
<span class="hljs-built_in">module</span>.exports = {
    setDirty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        dirty = <span class="hljs-literal">true</span>;
    },
};</code></pre><h2 id="--7">循环引用</h2>
<p>(Coming Soon...)</p>
      </article>
    </div>
  </div>
  <script src="../assets/js/anchor.min.js"></script>
  <script>
    anchors.add('article h2, article h3, article h4');
  </script>
  </body>
</html>
